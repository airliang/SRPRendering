#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Random.hlsl"

#pragma kernel HBAO
#pragma enable_d3d11_debug_symbols
#define PI 3.14159265358979323846

RWTexture2D<float> _AOMask;
Texture2D<float4> _NormalTexture;
Texture2D _DepthTexture;
float4x4 _ViewMatrix;  //platform unrelative matrix
float4x4 _ProjInverse; //platform unrelative matrix
float4x4 _ViewInverse; //use for test
float4 _HBAOParams;   
float4 _AOMaskSize;
float4 _ScreenSize;    //xy width and height, zw 1/width and 1/height
float _HalfResolution;
float2 _ProjectionParams;
#define RADIUS _HBAOParams.x    //radius in practice
#define BIAS   _HBAOParams.y
#define NEG_RADIUSINVSQR _HBAOParams.z  
#define RADIUSINPIXEL _HBAOParams.w
#define SAMPLE_COUNT 8
#define HALF_RESOLUTION _HalfResolution > 0

SamplerState s_point_clamp_sampler;
SamplerState s_linear_clamp_sampler;

static const float SKY_DEPTH_VALUE = 0.00001;

static const float2 SPIRAL_KERNEL[SAMPLE_COUNT] =
{
    float2(0.0239522, 0.05772818),
    float2(-0.1733557, -0.07144266),
    float2(0.288354, -0.1204501),
    float2(-0.1657328, 0.4048937),
    float2(-0.2180493, -0.5185179),
    float2(0.6368818, 0.2589166),
    float2(-0.7482157, 0.3167484),
    float2(0.3509923, -0.8693162)
};

float GetPlatformDepth(float depth)
{
    return 1.0 - depth;
}

float3 UVtoViewPos(float2 uv, float depth)
{
    float2 clippos = uv * 2.0 - 1.0;
    
    float4 posView = mul(_ProjInverse, float4(clippos, 2.0 * depth - 1.0, 1));
    posView /= posView.w;
    return posView.xyz;
}

float HorizontalFalloff(float3 normal, float3 horizonVec)
{
    float NdotV = dot(normal, horizonVec);
    return saturate(NdotV - BIAS);

}

float DistanceFalloff(float distanceSqr)
{
    return saturate(distanceSqr * NEG_RADIUSINVSQR + 1.0);
}

//----------------------------------------------------------------------------------
// P = view-space position at the kernel center
// N = view-space normal at the kernel center
// S = view-space position of the current sample
//----------------------------------------------------------------------------------
float ComputeAO(float3 P, float3 N, float3 S)
{
    float3 V = S - P;
    float VdotV = dot(V, V);
    //if (VdotV < 0.01)
    //    return 0;
    //float NdotV = dot(N, V) * 1.0 / sqrt(VdotV);

    // Use saturate(x) instead of max(x,0.f) because that is faster on Kepler
    return HorizontalFalloff(N, normalize(V)) * DistanceFalloff(VdotV);
}

[numthreads(8,8,1)]
void HBAO (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) _AOMaskSize.x || id.y >= (uint) _AOMaskSize.y)
    {
        return;
    }
    // TODO: insert actual code here!
    float2 uv = (float2) id.xy / _AOMaskSize;
    float2 uvScreen = uv + _ScreenSize.zw * 0.5 * _HalfResolution;
    
    float noise = InterleavedGradientNoise((float2)id.xy, 0);
    //float noise2 = InterleavedGradientNoise((float2) id.xy, 1);
    
    float theta = PI * 2.0 * noise;
    float cosTheta = cos(theta);
    float sinTheta = sin(theta);
    float2x2 rotation = float2x2(cosTheta, -sinTheta,
                                 sinTheta, cosTheta );
    
    
    //int2 screenCoord = _ScreenSize * uv;
    float depth = HALF_RESOLUTION ? _DepthTexture.SampleLevel(s_linear_clamp_sampler, uvScreen, 0) : _DepthTexture.SampleLevel(s_point_clamp_sampler, uvScreen, 0); //_DepthTexture.Load(int3(screenCoord, 0));
    if (depth < SKY_DEPTH_VALUE)
    {
        _AOMask[id.xy] = 1;
        return;
    }
    depth = GetPlatformDepth(depth);
    
    
    //float depth = _DepthTexture.Load(int3(screenCoord, 0));
    float3 normal = HALF_RESOLUTION ? _NormalTexture.SampleLevel(s_linear_clamp_sampler, uvScreen, 0) : _NormalTexture.SampleLevel(s_point_clamp_sampler, uvScreen, 0); //_NormalTexture.Load(int3(screenCoord, 0));
    normal = 2.0 * normal - 1.0;
    
    float3 screenPosVS = UVtoViewPos(uvScreen, depth);
    float3 normalVS = mul((float3x3)_ViewMatrix, normal);
    normalVS = normalize(normalVS);

    float AOIntegrate = 0;
    float radiusPixel = RADIUSINPIXEL / screenPosVS.z;
    for (int i = 0; i < SAMPLE_COUNT; ++i)
    {
        float2 samplePoint = mul(rotation, SPIRAL_KERNEL[i]) * radiusPixel * _ScreenSize.zw + uvScreen;
        //screenCoord = _ScreenSize * samplePoint;
        float depthSample = HALF_RESOLUTION ? _DepthTexture.SampleLevel(s_linear_clamp_sampler, samplePoint, 0) : _DepthTexture.SampleLevel(s_point_clamp_sampler, samplePoint, 0); //_DepthTexture.Load(int3(screenCoord, 0));
        depthSample = GetPlatformDepth(depthSample);
        float3 samplePointVS = UVtoViewPos(samplePoint, depthSample);
        
        AOIntegrate += ComputeAO(screenPosVS, normalVS, samplePointVS);
    }
    AOIntegrate /= SAMPLE_COUNT;

    _AOMask[id.xy] = saturate(1.0 - AOIntegrate);

}
