#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Random.hlsl"

#pragma kernel HBAO
#pragma enable_d3d11_debug_symbols
#define PI 3.14159265358979323846

RWTexture2D<float> _AOMask;
Texture2D<float4> _NormalTexture;
Texture2D _DepthTexture;
float4x4 _ViewMatrix;  //platform unrelative matrix
float4x4 _ProjInverse; //platform unrelative matrix
float4x4 _ViewInverse; //use for test
float4 _HBAOParams;   
uint2 _AOMaskSize;
float4 _ScreenSize;    //xy width and height, zw 1/width and 1/height
#define RADIUS _HBAOParams.x    //radius in practice
#define BIAS   _HBAOParams.y
#define RADIUSINVSQR _HBAOParams.z  
#define RADIUSINPIXEL _HBAOParams.w
#define SAMPLE_COUNT 8

static const float2 SPIRAL_KERNEL[SAMPLE_COUNT] =
{
    float2(0.0239522, 0.05772818),
    float2(-0.1733557, -0.07144266),
    float2(0.288354, -0.1204501),
    float2(-0.1657328, 0.4048937),
    float2(-0.2180493, -0.5185179),
    float2(0.6368818, 0.2589166),
    float2(-0.7482157, 0.3167484),
    float2(0.3509923, -0.8693162)
};

float GetPlatformDepth(float depth)
{
    return 1.0 - depth;
}

float3 UVtoViewPos(float2 uv)
{
    float2 clippos = uv * 2.0 - 1.0;
    int2 screenCoord = _ScreenSize.xy * uv;
    float depth = _DepthTexture.Load(int3(screenCoord, 0));
    depth = GetPlatformDepth(depth);
    float4 posView = mul(_ProjInverse, float4(clippos, depth, 1));
    posView /= posView.w;
    return posView.xyz;
}

float DistanceFalloff(float distanceSqr)
{
    return distanceSqr * RADIUSINVSQR + 1.0;
}

//----------------------------------------------------------------------------------
// P = view-space position at the kernel center
// N = view-space normal at the kernel center
// S = view-space position of the current sample
//----------------------------------------------------------------------------------
float ComputeAO(float3 P, float3 N, float3 S)
{
    float3 V = S - P;
    float VdotV = dot(V, V);
    float NdotV = dot(N, V) * 1.0 / sqrt(VdotV);

    // Use saturate(x) instead of max(x,0.f) because that is faster on Kepler
    return clamp(NdotV - BIAS, 0, 1) * clamp(DistanceFalloff(VdotV), 0, 1);
}

[numthreads(8,8,1)]
void HBAO (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _AOMaskSize.x || id.y >= _AOMaskSize.y)
    {
        return;
    }
    // TODO: insert actual code here!
    float2 uv = ((float2) id.xy + 0.5) / _AOMaskSize;
    float noise = InterleavedGradientNoise((float2) id.xy, 0);
    //float noise2 = InterleavedGradientNoise((float2) id.xy, 1);
    
    float theta = PI * 2.0 * noise;
    float cosTheta = cos(theta);
    float sinTheta = sin(theta);
    float2x2 rotation = float2x2(cosTheta, -sinTheta,
                                 sinTheta, cosTheta );
    
    
    int2 screenCoord = _ScreenSize * uv;
    //float depth = _DepthTexture.Load(int3(screenCoord, 0));
    float3 normal = _NormalTexture.Load(int3(screenCoord, 0));
    normal = 2.0 * normal - 1.0;
    float3 screenPosVS = UVtoViewPos(uv);
    float3 normalVS = mul((float3x3)_ViewMatrix, normal);
    normalVS = normalize(normalVS);

    float AOIntegrate = 0;
    float radiusPixel = RADIUSINPIXEL * screenPosVS.z;
    for (int i = 0; i < SAMPLE_COUNT; ++i)
    {
        float2 samplePoint = mul(rotation, SPIRAL_KERNEL[i]) * radiusPixel * _ScreenSize.zw + uv;
        float3 samplePointVS = UVtoViewPos(samplePoint);
        
        AOIntegrate += ComputeAO(screenPosVS, normalVS, samplePointVS);
    }
    AOIntegrate /= SAMPLE_COUNT;

    _AOMask[id.xy] = saturate(1.0 - AOIntegrate);

}
