// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TemporalFilter
#pragma enable_d3d11_debug_symbols
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float> _AOBlur;
Texture2D<float4> _CurrentHistory;
RWTexture2D<float4> _OutputHistory;
RWTexture2D<float> _AOOutput;
Texture2D _DepthTexture;
float4x4 _PreProjInverse;
float4x4 _ProjInverse;
float4x4 _PreProj;
float4x4 _ViewInverse;
float4x4 _PreView;
float3 _CameraDisplacement;
float4 _AOMaskSize;
//non camera relative pos
float4x4 _ViewProjInverse;
float4x4 _PreViewProj;
//----
#define SHADEROPTIONS_CAMERA_RELATIVE_RENDERING (1)
#define MAX_FRAME_NUM 8
SamplerState s_point_clamp_sampler;
SamplerState s_point_repeat_sampler;
SamplerState s_linear_clamp_sampler;

float3 UVtoViewPosCurFrame(float2 uv, float depth)
{
    float2 clippos = uv * 2.0 - 1.0;
    
    float4 posView = mul(_ProjInverse, float4(clippos, 2.0 * depth - 1.0, 1));
    posView /= posView.w;
    return posView.xyz;
}

float3 UVtoViewPosPreFrame(float2 uv, float depth)
{
    float2 clippos = uv * 2.0 - 1.0;
    
    float4 posView = mul(_PreProjInverse, float4(clippos, 2.0 * depth - 1.0, 1));
    posView /= posView.w;
    return posView.xyz;
}

float GetPlatformDepth(float depth)
{
    return 1.0 - depth;
}

float2 TemporalReprojection(float2 uv, float depth, out float preViewDepth, out float preAO)
{
    float4 projPosCur = float4(2.0 * uv - 1, depth, 1);
    float4 worldPos = mul(_ViewProjInverse, projPosCur);
    float4 preProjPos = mul(_PreViewProj, worldPos);
    preProjPos /= preProjPos.w;
    
    
    float2 uvPre = 0.5 * preProjPos.xy + 0.5;
    float4 aoHistory = _CurrentHistory.SampleLevel(s_linear_clamp_sampler, uvPre, 0); //_CurrentHistory[id.xy];
    float prevDepth = UnpackFloatFromR8G8(aoHistory.zw);
    float3 viewPosPreReal = ComputeViewSpacePosition(uvPre, prevDepth, _PreProjInverse);
    preViewDepth = viewPosPreReal.z;
    preAO = aoHistory.g;
    return uvPre;
}

[numthreads(8,8,1)]
void TemporalFilter (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    half2 uv = ((half2)id.xy + 0.5) * _AOMaskSize.zw;
    float depth = _DepthTexture.SampleLevel(s_point_clamp_sampler, uv, 0);
    //depth = GetPlatformDepth(depth);
    
    float3 viewPosCur = ComputeViewSpacePosition(uv, depth, _ProjInverse); //UVtoViewPosCurFrame(uv, depth);
    float4 worldPosCur = mul(_ViewInverse, float4(viewPosCur, 1));
    float4 projPosCur = float4(2.0 * uv - 1, depth, 1);
    float4 weightViewPos = mul(_PreView, worldPosCur); //mul(_PreProjInverse, projPosCur);
#if SHADEROPTIONS_CAMERA_RELATIVE_RENDERING == 1
    weightViewPos.xyz += _CameraDisplacement;
#endif
    weightViewPos.z = -weightViewPos.z;   //convert the view pos to right coordinate
    weightViewPos /= weightViewPos.w;

    
    float4 viewPosPre = weightViewPos;
    float4 projPosPre = mul(_PreProj, viewPosPre);
#if UNITY_UV_STARTS_AT_TOP
    // Our world space, view space, screen space and NDC space are Y-up.
    // Our clip space is flipped upside-down due to poor legacy Unity design.
    // The flip is baked into the projection matrix, so we only have to flip
    // manually when going from CS to NDC and back.
    projPosPre.y = -projPosPre.y;
#endif
    projPosPre /= projPosPre.w;
    float2 uvPre = 0.5 * projPosPre.xy + 0.5;
    
    
    
    float4 aoHistory = _CurrentHistory.SampleLevel(s_linear_clamp_sampler, uvPre, 0);
    float prevDepth = UnpackFloatFromR8G8(aoHistory.zw);
    float3 viewPosPreReal = ComputeViewSpacePosition(uvPre, prevDepth, _PreProjInverse);

    float weightCur = viewPosCur.z; //we have to convert the z to left coordinate
    float weightPre = viewPosPreReal.z;

    
    float ao = _AOBlur.SampleLevel(s_linear_clamp_sampler, uv, 0); //_AOBlur[id.xy]; //aoHistory.r;
    float aoPre = aoHistory.g;
    float finalAO = ao;
    int Ncur = 1;
    int Npre = UnpackByte(aoHistory.r);
    //disocclusion detecting
    if (abs(1.0 - weightCur / weightPre) < 0.1)
    {
        //float aoPre = _PreviousHistory[id.xy];
        finalAO = (ao + aoPre * Npre) / (Npre + 1);
        Ncur = min(Npre + 1, MAX_FRAME_NUM);
    }
    
    //float curViewDepth = viewPosCur.z;
    //float preViewDepth = 0;
    //float preAOTest = 0;
    //float2 uvPreTest = TemporalReprojection(uv, depth, preViewDepth, preAOTest);
    //if (abs(1.0 - curViewDepth / preViewDepth) < 0.1)
    //{
    //    finalAO = (ao + aoPre * Npre) / (Npre + 1);
    //    Ncur = min(Npre + 1, MAX_FRAME_NUM);
    //}
    
    float4 aoCurHistory = float4(PackByte(Ncur), finalAO, PackFloatToR8G8(depth));
    _OutputHistory[id.xy] = aoCurHistory;

    _AOOutput[id.xy] = finalAO;

}
